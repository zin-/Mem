# Architecture

Software architecture.

ITシステムのアーキテクチャを整理する

## Memo

- 開発するときに試したいと思ったコーディングスタイルや、ライブラリを使いたいので、常に機能単位で分かれていてほしい
  - レイヤーアーキテクチャ（クリーンアーキテクチャやMVC, MVVMパターンなど）は採用しない
- ~~マイクロサービスが近いかもしれない~~
  - バックエンドとしてデプロイするときも、同じコードを使いたいので、マイクロサービスっぽい方がやりやすそう
  - サービス（ランタイム）を分けたり分けなかったりしたいので、違う概念な気がする
- （とりあえず）feature architecture とする
  - 機能ごとにディレクトリを定義し、それぞれその中だけで完結するよう努力する
- 基本的に関わる要素が少ないほどランニングコストは小さくなる
  - 障害・脆弱性・メンテナンスコスト
  - 外部要因が変わったり、仕様を変えるときに要素が少ないと範囲が不明瞭になる
    - 凝集度が低かったり
    - 具体的には1ファイル1クラスだとしたら何を変えるにしても難しい
    - 変更が容易で、要素を減らすにはどうしたらいいのか
      - 拡張可能なデフォルトがあれば良い？
- 具体例から考える
  - Core
    目的を実現するための処理
    - 実現したいことによって自由に定義して良い
    - 理想的にはcoreの外への依存はなくしたい
      - 外部システムにアクセスしないライブラリをラップ、カスタマイズする場合は依存OK
        - ライブラリの性質による？
          - 使うライブラリによって概念が変わるのってどうなん？
            - むしろ変わらない方がおかしくて、気にしてなかったのが間違いかも
        - 基本的にライブラリは、自分でも書けるけどコストが高い上に質で劣る場合が多いので、利用するもの
          - コスト削減してるだけ
          - なので、その性質によって参照できる抽象概念が異なるのは自然なこと
      - ただし、ライブラリを切り替えたり独自実装に切り替えることを考慮に入れたいので、アダプターとして何かを挟むこと
  - Script
    - CLIから実行されて、CLI上に出力する
    - 入力を処理して、返却する
    - Coreは純粋関数のみで実装できるはず
    - モジュール
      - interface
        CLIから情報を受け取り返却する処理
        - IFはテキストの入出力のみ
        - 入力の型チェック
          - ここで問題があれば、エラーを返却する
        - 入力の整形
        - 処理の実行
          - できれば1つの呼び出しだけにしたい
        - 処理結果の整形
        - 処理結果の出力
        - coreを呼び出す
  - With Data store
    - データストアとの連携
      - 読み込みと書き込みがある
    - 自システムとData store との境界
      - Repository
        - ドメインオブジェクトのコレクションとして振る舞う
        - データアクセスのメカニズムを隠蔽する
        - 中にDAOを持つ
          - DAOへのアクセスはRepository もしくはテストからしか許さない
            - つまりrepository の持ち物
      - Data Access Object
        - データアクセスのメカニズムを隠蔽する
          - この処理を独自に実装するのはコストが大きいため、既存の他システムに依存することが多い
            - Data store
              - Database
                - Relational
                - Key-Value
                - Document
              - File
              - RESTful api
        - アクセスの単位（テーブル、ファイルなど）で実装する
          - 継承するだけになることが多いと思うけど
        - 取り扱うのはData storeとのやり取りがしやすいデータ型（entityとか、カラムそのままのクラス）
    - 忘れられがちなData store
      - Logger
    - Data storeを定義するための情報を別で持つ必要がある
      - [x]  自動生成されるべきとは言えない
      - [x]  他システムの設定値ということになる
      - [x]  設定することまでrepositoryの責務には持たない
      - [x]  バッチっぽく感じる
        - バッチとして定義する
    - repository にはどこからアクセスするか？
      - Coreから？
  - With Repository
    - With Data storeを拡張し、外部システム全般を扱うようにする
      - 含まれていなかったのはRESTful API
        - Web APIではない
    - 読み書きでないものは対象外
  - ~~With Clock~~
    - 時間情報
    - 純粋関数とは言えない気がする
      - 実行環境に依存する？
        - 作り次第？
      - 参照透過じゃないから合ってる
    - 関数に与えるべきものなだけで、特別に扱うものではない
      - 具体的にはPersistenceに含める
    - Location とかも同様にする
- Software architecture

  基本的なソフトウェアの構成はデータとアルゴリズムだと思うので、それぞれに関心を分けて記述したい

  - Inner
    - Core

      アルゴリズム、つまり処理こそがソフトウェアの中心であり、キモ、重要な部分なので、Coreという語が適切だと思った

      - Domain
        - Object
      - Service
    - Repository

      倉庫というイメージで、DAOよりも抽象度の高い概念としてよく用いられる

      これを使うとデータの保存方法を関心から外せるのでDIできる

      より適切な語があるような気がする

      - Data source
        - Database
          - Relational database
          - Indexed database
        - Log
        - Key value store
      - API
        - Web API
        - Platform API
    - DAO

      Data access object

      Repository が使う

    - Wrapper

      外部のライブラリを使う場合に用いる

      - 適切な抽象化を行えていれば、内部のライブラリを変更するだけでラッパーの変更は不要になるはず
      - システムが大きくなるほど依存は増えるので、ライブラリごとにラッパーを管理したくはない
        - ある程度のまとまりでラッパーにする？
  - Outer
    - Application
      - 画面、web routesなどそのシステムへのアクセス部分
  - ディレクトリ構成
    - 最適なアーキテクチャを探りつつ実装したい
    - 機能ごとにアーキテクチャが変わることを許容したい
    - アーキテクチャの提案と機能実装を別に定義する
    - root
      - ~~architecture~~ framework

        抽象クラスで定義される、システムの概形

        フレームワーク

        - core
          - domain

            オブジェクト単位で定義する

            フレームワーク内では定義しない

          - service

            domain, repository を参照して処理を実装する

        - repository
          - dao

            データストアへのアクセスを担う

          - entity

            データの保存単位で定義する

        - wrapper

          ライブラリをラップする

          目的に応じて適切に抽象化することで、ライブラリの変更が容易になるように注意する

      - feature 1
      - feature 2
- About Test
  - 自分が書いたコードは全てテストするべき
    - C1 100%
  - モックは自分が書いてないとこだけ？
    - 1ファイル単位でテストし、依存対象をモックする方針で依存対象も開発対象だとすると、依存対象の実装が変わったときにモックにも反映されるとは限らないので、テストが陳腐化する可能性がある
- why backend
  - データ
    - 隠蔽
      - （frontend（というかclientか？）にあると解析されて）他者に参照されると困るものを隠しておく役割がある
        - ユーザデータ
          - 個人情報
          - 決済情報
          - 機密情報
    - 共有
      - 各クライアントがデータを保持し、必要な場合に各々で問い合わせを行うのは難しい
        - 通話など双方向通信のためにコネクションを維持する難しさ
        - データは1:nになることが多く、コネクション数も大きくなり、管理・スペック面で厳しさがある
  - アルゴリズム
    - スペック
      - バックエンドのサーバは一般的にはクライアント端末よりもスペックの幅が広く適切なスペックを提供しやすい
    - ロジックの隠蔽
      - 解析を防ぐ事ができる
    - 共有
      - クライアント端末の更新はクライアントのオーナーが権利を持つが、バックエンドはプロバイダー側が変更する事ができる
- ~~メインの言語を何にするか考える~~
  - メインという概念を作らないほうが良いかも？
  - ~~マイクロサービス化することを念頭において、どんな言語でも作れるようにするべきな気がする~~
    - ~~マイクロサービス化に当たって検討すること~~
      - マイクロサービスとは
        - 納得できる定義がなかったので、この概念は使わない
        - 自分で理想や課題を上げて考える